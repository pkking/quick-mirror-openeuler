#!/usr/bin/python
from __future__ import print_function

# quick-fedora-hardlink uses the the fullfiletimelist files present in the
# Fedora repository, as well as some specific properties of the structure of
# the Fedora repository, to "quickly" hardlink identical files in that
# repository.

# In the Fedora repository, all files which are hardlinked also have exactly
# the same names.  We also know that all files should have the same
# permissions, and so we don't need to check them.
#
# The specific property it uses is the fact that all hardlinked files will have
# the same name.

# Generally, quick-fedora-mirror will maintain hardlinks as they are present on
# the master mirror.  However, there are situations where it won't:
# * If a module is added without backdating.
# * If files need to be retransferred for any reason.
# * If the file lists on the master aren't generated for each crosslinked
#   module together when linking occurs.

import argparse
import os
import stat
import sys


def parseopts():
    p = argparse.ArgumentParser(
        description='Using the file lists, quickly hardlink'
        'identical files in the mirrored repositories.')

    p.add_argument('-c', '--config', help='Path to the configuration file.')
    p.add_argument('-d', '--debug', help='Debug level.')
    p.add_argument('-n', '--dry-run', action='store_true',
                   help='Just print what would be done without linking anything.')
    p.add_argument('-p', '--progress', action='store_true',
                   help='Show progress information on stderr.')

    opts = p.parse_args()

    # Check that config file is readable.
    if opts.config and not os.access(opts.config, os.R_OK):
        print('Cannot open provided config file {}'.format(opts.config), file=sys.stderr)
        sys.exit(1)

    if not opts.config:
        for i in ('/etc/quick-fedora/mirror.conf',
                  os.path.expanduser('~/.config/quick-fedora-mirror.conf'),
                  '{}/quick-fedora-mirror.conf'.format(os.path.dirname(__file__)),
                  './quick-fedora-mirror.conf'):
            if os.access(i, os.R_OK):
                opts.config = i
                break
        else:
            print('Could not find a readable configuration file.', file=sys.stderr)
            sys.exit(1)

    return opts


def readconfig(opts):
    """Read the configuration file.

    We really only want DESTD and FILELIST
    The value is stored in the existing options array.
    """
    with open(opts.config) as cf:
        for line in cf.readline():
            pass


def main():
    opts = parseopts()
    readconfig(opts)
    exit


def cmp(f1, f2):
    """Lifted from the inner comparison of filecmp.py.

    The rest of filecmp.py isn't useful, and results in too many stat calls for
    our purposes.
    """
    bufsize = 8 * 1024
    with open(f1, 'rb') as fp1, open(f2, 'rb') as fp2:
        while True:
            b1 = fp1.read(bufsize)
            b2 = fp2.read(bufsize)
            if b1 != b2:
                return False
            if not b1:
                return True


def _sig(st):
    return (stat.S_IFMT(st.st_mode),
        st.st_size,
        st.st_mtime)

# """
# VERBOSE=0
# FILELIST='fullfiletimelist-$mdir'

# # Override with the command-line option
# [[ -n $verboseopt ]] && VERBOSE=$verboseopt

# # Make a tempdir and trap.
# tempd=$(mktemp -d -t quick-hardlink.XXXXXXXXXX)
# tuples=$tempd/alltuples
# if (( VERBOSE <= 8 )); then
    # trap "rm -rf $tempd" EXIT
# fi

# cd $DESTD
# filelists=()
# totallines=0
# for mdir in *; do
    # if [[ ! -d $mdir ]]; then
    # continue
    # fi
    # # Look for a file list in there
    # flname=$mdir/${FILELIST/'$mdir'/$mdir}

    # if [[ -f $flname ]]; then
        # tmpname=$tempd/files-$mdir
        # db2 "Exracting file list from $flname."
        # linecount=$(wc -l < $flname)

        # awk -v PROG=$progress -v MDIR=$mdir -v TL=$linecount -F'\t' '
            # /^\[Files/ {
                # s = 1
                # next
            # }
            # /^$/ {
                # s = 0
                # next
            # }
            # s && $2 == "f" {
                # printf("%s/%s\t%s\n", MDIR, $4, $3)
            # }
            # PROG == 1 && NR % 100000 == 0 {
                # printf("  Processed %10d lines, %3.2f%% done\n", NR, 100*NR/TL) > "/dev/stderr"
            # }
        # ' $flname > $tmpname

        # filelists+=($tmpname)
        # linecount=$(wc -l < $tmpname)
        # totallines=$((totallines + linecount))
        # db2f "%7d total files in %s.\n" $linecount $flname
    # fi
# done

# # ZSHISM? array member coount
# echo "Lists to process: $#filelists"
# echo "Total lines: $totallines"

# awk -v TL=$totallines -v PROG=$progress -F'\t' '
    # $1 ~ /\// {
        # bn = (basename($1) $2)
        # if (allfiles[bn]) {
            # multiples[bn]=1
            # allfiles[bn] = (allfiles[bn] "\t" $1)
        # }
        # else {
            # allfiles[bn] = $1
        # }
    # }
    # PROG== 1 && FNR == 0 {
        # printf("Processing %s\n", FILENAME) > "/dev/stderr"
    # }
    # PROG == 1 && NR % 100000 == 0 {
        # printf("  Processed %10d lines, %3.2f%% done\n", NR, 100*NR/TL) > "/dev/stderr"
    # }

    # END {
        # for (key in multiples) {
            # print allfiles[key]
        # }
    # }

    # function basename(pn) {
        # if (sub(".*/", "", pn)) {
            # return pn
        # }
    # }
# ' $filelists >> $tuples

# sort $tuples > $tuples-sorted

# # Now we have this big file with all tuples
# sep
# linecount=$(wc -l < $tuples-sorted)
# db2 "Found $linecount potential hardlinkable tuples."

# tuple=()
# count=0
# # ZSHISM read into array.  Bash uses readarray?
# while IFS=$'\t' read -A tuple; do
    # count=$((count+1))
    # if (( count % 10000 == 0 )); then
        # pct=$(( 100 * count / linecount ))
        # printf "========= %8d processed (%2.2) =========\n" $count $pct
    # fi
    # target=$tuple[1]
    # targetinode=$(stat -c %i $target)

    # # ZSHISM does bash even have array slicing?
    # for candidate in ${tuple[2,-1]}; do

        # # First check inodes to weed out already linked files
        # candidateinode=$(stat -c %i $candidate)
        # if (( targetinode == candidateinode )); then
            # db3 "$target and $candidate are already hardlinked."
            # continue
        # fi

        # # Then actually check the file contents
        # cmp -s $target $candidate
        # if [[ $? != 0 ]]; then
            # db2 "$target and $candidate share the same name but have different contents."
            # continue
        # fi

        # db2 "$target and $candidate are the same and can be hardlinked."

        # if [[ $skiplink == 1 ]]; then
            # continue
        # fi

        # # And now we can hardlink.
        # candidatedir=$(dirname $candidate)
        # tempfile=$(mktemp -p $candidatedir quick-hardlink.XXXXXXXXXX)
        # if [[ $? != 0 ]]; then
            # (>&2 echo "Could not create temporary file in $candidatedir.")
            # exit 1
        # fi

        # # Move the candidate out of the way.
        # mv $candidate $tempfile
        # if [[ $? != 0 ]]; then
            # (>&2 echo "Could not rename $candidate.")
            # exit 1
        # fi

        # # Make the link
        # ln $target $candidate
        # if [[ $? != 0 ]]; then
            # (>&2 echo "Could not link from $candidate to $target. Trying to undo the rename.")
            # mv $tempfile $candidate
            # if [[ $? != 0 ]]; then
                # (>&2 echo "Could not rename $tmpfile to $candidate!  You will
                # need to fix things up manually.")
            # else
                # (>&2 echo "Undid the rename.")
            # fi
        # fi

        # # Delete the tempfile.
        # rm -f $tempfile
        # if [[ $? != 0 ]]; then
            # (>&2 echo "Could not delete the tempfile $tempfile.  You will need to clean this up manually.  Continuing.")
        # fi
    # done
# done < $tuples-sorted
# """


if __name__ == '__main__':
    main()
