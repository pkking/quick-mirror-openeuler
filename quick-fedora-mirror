#!/bin/zsh
export LANG=C
IFS=$'\n'

# Simple script to grab the file list from Fedora and rsync everything that's
# changed since the last time we pulled.
#
# Originally written by Jason Tibbitts <tibbs@math.uh.edu> in 2016.
# Donated to the public domain.  If you require a statement of license, please
# consider this work to be licensed as "CC0 Universal", any version you choose.

# Variables in upper case are user configurables.

# Do this absolutely first
starttime=$(date +%s)
# Paranoia
starttime=$(($starttime-5))

# Utility functions

db1 () { (( VERBOSE >= 1 )) && echo $* }
db2 () { (( VERBOSE >= 2 )) && echo $* }
db3 () { (( VERBOSE >= 3 )) && echo '>>' $* }
db4 () { (( VERBOSE >= 4 )) && echo '>>>>' $* }
sep () { (( VERBOSE >= 2 )) && echo '============================================================' }
db2f () { (( VERBOSE >= 2 )) && printf $* }

finish () {
    if (( $VERBOSE >= 1 )); then
        echo -n 'Mirror finished: '
        date
    fi
    exit 0
}

do_rsync () {
    # Options: source, destination.
    # The name of an array containing additional options.
    # If rsync fails, this will sleep with
    # exponential backoff ten times, and then will exit the script (not just
    # the function).
    local src=$1
    local dest=$2
    local files=$3
    local opts=$4
    local sleep=1
    local log=rsync.log
    local errlog=rsync-error.log

    local -a verboseopts
    # These add to the default rsync verbosity
    (( VERBOSE >= 7 )) && verboseopts+=(--progress)
    (( VERBOSE >= 5 )) && verboseopts+=(-v)
    (( VERBOSE >= 4 )) && verboseopts+=(-v)

    # These remove from the default rsync verbosity
    (( VERBOSE <= 3 )) && verboseopts+=(--no-motd)
    (( VERBOSE == 0 )) && verboseopts+=(-q)

    flopts=(--files-from=$files)

    while true; do
        # ZSHISM:  (P) flag to act on a variable by name.  Sadly, bash has
        # broken array handling.   bash 4.3 has local -n for this.  Older bash
        # needs hacks, or eval.  More info:
        # https://stackoverflow.com/questions/1063347/passing-arrays-as-parameters-in-bash
        # Or just use a freaking global.

        # We have to do this separately because you can't redirect to /dev/stderr when running under sudo.
        if (( VERBOSE >= 5 )); then
            db3 Calling $RSYNC $RSYNCOPTS $verboseopts $flopts ${(P)opts} $src $dest
            $RSYNC $RSYNCOPTS $verboseopts $flopts ${(P)opts} $src $dest
            rsyncreturn=$?
        elif (( VERBOSE >= 2 )); then
            db3 Calling $RSYNC $RSYNCOPTS $verboseopts $flopts ${(P)opts} $src $dest \>\> $log
            $RSYNC $RSYNCOPTS $verboseopts $flopts ${(P)opts} $src $dest >> $log
            rsyncreturn=$?
        else
            db3 Calling $RSYNC $RSYNCOPTS $verboseopts $flopts ${(P)opts} $src $dest \>\> $log 2\>\> $errlog
            $RSYNC $RSYNCOPTS $verboseopts $flopts ${(P)opts} $src $dest >> $log 2>> $errlog
            rsyncreturn=$?
        fi

        (( rsyncreturn != 5 && rsyncreturn != 10 )) && break

        db2 rsync failed: sleeping for $sleep
        sleep $sleep
        sleep=$(( sleep*2 ))
        if (( sleep > 1000 )); then
            (>&2 echo "Could not sync from $REMOTE/$module")
            [[ -f $errlog ]] && (>&2 cat $errlog)
            exit 1
        fi
    done

    # If we got here, we have a successful run.
    # XXX Grep the "interesting" information from the logs, according to verbosity.
    #   2 - Only some of stdout (the summary line at the end of the transfer)
    #   5 - Now start showing more output.  What to show?

    return $rsyncreturn
}

# Parse args
while [[ $# > 0 ]]; do
    opt=$1
    case $opt in
        -a)
            alwayscheck=1
            ;;
        -c)
            cfgfile=$2
            shift
            if [[ ! -r $cfgfile ]]; then
                (>&2 echo Cannot read $cfgfile)
                exit 1
            fi
            ;;
        -d) # Debugging
            verboseopt=$2
            shift
            ;;
        -n)
            rsyncdryrun=1
            skipdelete=1
            skiptimestamp=1
            ;;
        -N)
            skipdelete=1
            skiptimestamp=1
            ;;
        -t)
            backdate=$2
            alwayscheck=1
            shift
            ;;
        -T)
            backdate=$(date -d "$2" +%s)
            alwayscheck=1
            shift
            ;;
        *)
            (>&2 echo "Unrecognized argument.")
            exit 1
            ;;
    esac
    shift
done

# Mapping from module names to directories under fedora-buffet
# ZSHISM (initialize associative array)
typeset -A MODULEMAPPING
MODULEMAPPING=(
    fedora-alt          alt
    fedora-archive      archive
    fedora-enchilada    fedora
    fedora-epel         epel
    fedora-secondary    fedora-secondary
    )

# Default arguments; override in quick-fedora-mirror.conf
VERBOSE=0

DESTD=
TIMEFILE=

CHECKIN_HOST=$(hostname)
CURL=/usr/bin/rsync
FILELIST='fullfiletimelist-$mdir'
MIRRORMANAGER=https://admin.fedoraproject.org/mirrormanager/checkin
REMOTE=rsync://dl.fedoraproject.org
RSYNC=/usr/bin/rsync

rsyncver=$(rsync --version | head -1 | awk '{print $3}')
if [[ $rsyncver == 3.1* ]]; then
    RSYNCOPTS=(-aSH -f 'R .~tmp~' --preallocate --fuzzy --delay-updates)
else
    RSYNCOPTS=(-aSH -f 'R .~tmp~' --fuzzy --delay-updates)
fi

MASTERMODULE=fedora-buffet
MODULES=(fedora-enchilada fedora-epel)

# Load up the configuration file
for file in $cfgfile /etc/quick-fedora-mirror.conf \
        ~/.config/quick-fedora-mirror.conf \
        $(dirname $0)/quick-fedora-mirror.conf \
        ./quick-fedora-mirror.conf; do
    if [[ -r $file ]]; then
        source $file
        break
    fi
done

# Override with the command-line option
[[ -n $verboseopt ]] && VERBOSE=$verboseopt

# Check that the required parameters were provided
if [[ -z $DESTD ]]; then
    (>&2 echo "You must define DESTD in your configuration file ($configfile).")
fi
if [[ -z $TIMEFILE ]]; then
    (>&2 echo "You must define TIMEFILE in your configuration file ($configfile).")
fi

# Find the previous mirror time, and backdate if necessary
LASTTIME=0
if [[ -r $TIMEFILE ]]; then
    source $TIMEFILE
fi
if [[ -n $backdate ]]; then
    LASTTIME=$backdate
fi

# Make a temp dir and clean it up unless we're doing a lot of debugging
tempd=$(mktemp -d -t quick-mirror.XXXXXXXXXX)
if [[ $? -ne 0 ]]; then
    (>&2 echo "Creating temporary directory failed?")
    exit 1
fi
if (( VERBOSE <= 8 )); then
    trap "rm -rf $tempd" EXIT
fi
cd $tempd

# Some startup output depending on selected verbosity.
if (( VERBOSE >= 1 )); then
    echo -n 'Mirror starting: '
    date
fi

if (( VERBOSE >= 6 )); then
    echo Times:
    echo LASTTIME=$LASTTIME
    echo starttime=$starttime
    echo TIMEFILE=$TIMEFILE
    echo Dirs:
    echo tempd=$tempd
    echo DESTD=$DESTD
    echo Rsync:
    echo REMOTE=$REMOTE
    echo MASTERMODULE=$MASTERMODULE
    echo RSYNC=$RSYNC
    echo RSYNCOPTS=$RSYNCOPTS
    echo Modules:
    echo MODULES=$MODULES
    echo MODULEMAPPING=$MODULEMAPPING
    echo Misc:
    echo VERBOSE=$VERBOSE
fi

(( VERBOSE >= 8 )) && set -x

if [[ -n $MIRRORBUFFET ]]; then
    # We want to mirror everything, so save the admin from listing the
    # individual modules.
    # ZSHISM (get keys from an associative array with (k))
    MODULES=(${(k)MODULEMAPPING})
fi


# Master file list fetching
# =========================
sep
db2 Downloading file lists
# ZSHISM (declare associative array)
typeset -A fltimes
for module in $MODULES; do
    # ZSHISM? (associative array indexing)
    moduledir=$MODULEMAPPING[$module]
    mkdir $moduledir
    flname=${FILELIST/'$mdir'/$moduledir}

    # ZSHISM (assign assoc. array value)
    fltimes[$module]=0
    if [[ -f $DESTD/$moduledir/$flname ]]; then
        cp -p $DESTD/$moduledir/$flname $moduledir
        # So that we can diff it later
        cp -p $moduledir/$flname $flname.old
        # ZSHISM (assign assoc. array value)
        fltimes[$module]=$(stat --format=%Y $moduledir/$flname)
    fi

    echo $moduledir/$flname >> filelist-transferlist
done

extra=(--no-dirs --relative)
do_rsync $REMOTE/$MASTERMODULE/ . filelist-transferlist extra

# rsync won't transfer those files to the current directory, so move them and
# clean up.
mv */* .
rmdir * 2> /dev/null

# File list generation
# ====================
for module in $MODULES; do
    # ZSHISM? (associative array indexing)
    moduledir=$MODULEMAPPING[$module]

    fl=${FILELIST/'$mdir'/$moduledir}
    totallines=0

    # First fetch each filefiletimelist, and make one big transfer list from
    # all of them.  Copy in the old file from our repo to speed up rsync in case
    # most of it didn't change
    if [[ -z $alwayscheck && -f $fl.old && $(stat --format=%Y $fl.old) == $(stat --format=%Y $fl) ]]; then
        db2 No change in file list mtime.  Skipping $module.
        continue
    fi

    sep
    db2 Processing $module

    if [[ $VERBOSE -ge 6 && -f $fl.old ]]; then
        echo "Changes in file list since last run:"
        diff -u $fl.old $fl
    fi

    flversion=$(awk -F '\t' '/^\[Version/ {s=1; next} /^$/ {exit} {if (s) print $0}' < $fl)
    if [[ "$flversion" != '2' ]]; then
        (>&2 echo File list version from the mirror cannot be processed by this script.
        echo Skipping $module.)
        continue
    fi

    # Extract checksums up front in order to use that as a syntax check on the file list.
    awk -F '\t' "/^\[Checksums/ {s=1; next} /^$/ {s=0; next} {if (s) print \$1 \"\\t$moduledir/\" \$2}" $fl > checksums-$module

    if [[ ! -s checksums-$module ]]; then
        (>&2 echo "No checksums section.  Corrupted file list?"
        echo Skipping $module.)
        continue
    fi

    db3 Extracting file and directory lists.

    # All files in the remote repository.
    # Extract with the sizes and then extract just the file names from that.
    awk -F '\t' "/\\[Files/ {s=1;next} /^\$/ {s=0;next}
                 {if (s && \$2 == \"f\" || \$2 == \"l\")
                        print \"$moduledir/\" \$4 \"\t\" \$3}
                " $fl > allfilesizes-$module
    awk -F '\t' '{print $1}' allfilesizes-$module > allfiles-$module

    # All dirs in the remote repository.
    awk -F '\t' "/\\[Files/ {s=1;next} /^\$/ {s=0;next}
                 { if (s && \$2 == \"d\")
                        print \"$moduledir/\" \$4}
                " < $fl > alldirs-$module

    linecount=$(wc -l < allfiles-$module)
    linecount2=$(wc -l < alldirs-$module)
    db2f "Total on server:       %7d files, %4d dirs.\n" $linecount $linecount2

    # Files on the server which changed since the last run
    awk -F '\t' "/\\[Files/ {s=1;next} /^\$/ {s=0;next}
                 { if (s && \$1 >= $LASTTIME && (\$2 == \"f\" || \$2 == \"l\"))
                        print \"$moduledir/\" \$4}
                " < $fl > newfiles-$module

    # Dirs on the server which changed since the last run
    awk -F '\t' "/\\[Files/ {s=1;next} /^\$/ {s=0;next}
                 { if (s && \$1 >= $LASTTIME &&(\$2 == \"d\"))
                        print \"$moduledir/\" \$4}
                " < $fl > newdirs-$module

    linecount=$(wc -l < newfiles-$module)
    linecount2=$(wc -l < newdirs-$module)
    db2f "New on server:         %7d files, %4d dirs.\n" $linecount $linecount2

    echo $moduledir/$fl >> newfiles-$module
    cat newfiles-$module >> transferlist-$module
    cat newdirs-$module >> transferlist-$module
    totallines=$((totallines+linecount+linecount2+1))

    if [[ -d $DESTD/$moduledir ]]; then
        db3 Generating local file/dir list

        # Traverse the filesystem only once
        pushd $DESTD
        find $moduledir/* -printf '%y\t%p\t%s\n' > $tempd/localfulllist-$module
        popd

        awk -F '\t' '{if ($1 == "d") {print $2}}' < localfulllist-$module > localdirs-$module

        # Look for stray .~tmp~ dirs
        if [[ -z $NORSYNCRECOVERY ]]; then
            grep '\.~tmp~' localdirs-$module > staletmpdirs-$module
        fi

        if [[ -s staletmpdirs-$module ]]; then
            db2 Possibly aborted rsync run.  Cleaning up.

            # Move the files in those tmpdirs a level up if a file with the
            # same name doesn't exist.  We don't update the file lists because
            # we want rsync to re-check those files and possibly fix up the
            # permissions.  The dirs will be cleaned up later.
            # Note that this _may_ leave a few files around which should not be
            # there.  They will of course be cleaned up at the next run.
            # XXX We could do better by comparing the stale files against the
            #   to-be-fransferred list, but it's probably not worth it.
            for dir in $(cat staletmpdirs-$module); do
                pushd $DESTD/$dir
                for file in *; do
                    if [[ ! -f ../$file ]]; then
                        db3 Saving previous download: $file
                        mv $file ..
                    fi
                done
                popd
            done
        fi

        # Now extract file and dir lists from that
        awk -F '\t' '{if ($1 == "f" || $1 == "l") {print $2}}' < localfulllist-$module > localfiles-$module
        awk -F '\t' '{if ($1 == "f" || $1 == "l") {print $2 "\t" $3}}' < localfulllist-$module > localfilesizes-$module

        # Find files on the client which don't exist on the server
        sort allfiles-$module allfiles-$module localfiles-$module | uniq -u > deletefiles-$module
        cat deletefiles-$module >> master-deletefiles

        # Find dirs on the client which don't exist on the server
        sort alldirs-$module alldirs-$module localdirs-$module | uniq -u > deletedirs-$module
        cat deletedirs-$module >> master-deletedirs

        # Extract dirnames of every file and dir in the delete lists, and all of their parents.
        awk '{dn($0)} function dn(p) { while (sub(/\/[^\/]*\]?$/, "", p)) print p }' \
            deletefiles-$module deletedirs-$module | sort -u > updatetimestamps-$module
        cat updatetimestamps-$module >> master-updatetimestamps

        # Find files on the server which are missing on the client
        sort localfiles-$module localfiles-$module allfiles-$module | uniq -u > missingfiles-$module
        cat missingfiles-$module >> transferlist-$module

        # Find dirs on the server which are missing on the client
        sort localdirs-$module localdirs-$module alldirs-$module | uniq -u > missingdirs-$module
        cat missingdirs-$module >> transferlist-$module

        # Find files which have changed size
        sort allfilesizes-$module localfilesizes-$module | uniq -u | awk -F '\t' '{print $1}' | uniq -d > updatedfiles-$module
        cat updatedfiles-$module >> transferlist-$module

        pushd $DESTD > /dev/null 2>&1
        sha1sum --check --quiet $tempd/checksums-$module 2> /dev/null | grep -i 'failed$' | awk -F: '{print $1}' > $tempd/checksumfailed-$module
        popd > /dev/null 2>&1
        cat checksumfailed-$module >> transferlist-$module

        linecount=$(wc -l < localfiles-$module)
        linecount2=$(wc -l < localdirs-$module)
        db2f "Total on client:       %7d files, %4d dirs.\n" $linecount $linecount2

        linecount=$(wc -l < deletefiles-$module)
        linecount2=$(wc -l < deletedirs-$module)
        db2f "Not present on server: %7d files, %4d dirs.\n" $linecount $linecount2

        linecount=$(wc -l < missingfiles-$module)
        linecount2=$(wc -l < missingdirs-$module)
        totallines=$((totallines+linecount+linecount2))
        db2f "Missing on client:     %7d files, %4d dirs.\n" $linecount $linecount2

        linecount=$(wc -l < updatedfiles-$module)
        totallines=$((totallines+linecount))
        db2f "Size Changed:          %7d files.\n" $linecount

        linecount=$(wc -l < updatetimestamps-$module)
        db2f "Timestamps to restore: %7d files.\n" $linecount

        linecount=$(wc -l < checksumfailed-$module)
        totallines=$((totallines+linecount))
        db2f "Checksum Failed:       %7d files.\n" $linecount
    fi

    sort -u transferlist-$module >> transferlist-sorted-$module
    cat transferlist-sorted-$module >> master-transferlist
    linecount=$(wc -l < transferlist-sorted-$module)

    db2 Finished processing $module.
    db2 After removing duplicates, $linecount files and dirs were added to the transfer list.

    # Clean up a bit.
    # XXX We need at least the dirlists for the checkin
    #if (( VERBOSE <= 4 )); then
    #    rm *-$module
    #fi
done

if [[ ! -e master-transferlist ]]; then
    db2 No changed files.
    finish
fi

# The actual transfer
# ===================
sort -u master-transferlist > master-transferlist.sorted
linecount=$(wc -l < master-transferlist.sorted)
sep; sep
db2 Transferring $linecount files.

# Now we have a list of everything which has changed recently in every module
# we want, pass that to rsync (non recursive mode!) and it should transfer just
# the changed files without having to pull the entire huge file list.
extra=()
if [[ -n $rsyncdryrun ]]; then
    extra+=(-n)
fi
do_rsync $REMOTE/$MASTERMODULE/ $DESTD master-transferlist.sorted extra

if [[ $? -ne 0 ]]; then
    (>&2 echo "rsync finished with nonzero exit status.\nWill not check in or delete anything.")
    skipdelete=1
    rsyncfail=1
fi

# Local dir/file deletion
# =======================
if [[ -s master-deletedirs ]]; then
    linecount=$(wc -l < master-deletedirs)

    if [[ -n $skipdelete ]]; then
        echo Not deleting  $linecount directories.  Delete list is:
        cat master-deletedirs
        echo
    else
        db2 Removing $linecount stale directories.
        for nuke in $(cat master-deletedirs); do
            if [[ -d "$DESTD/$nuke" ]]; then
                db4 Removing $nuke
                rm -rf "$DESTD/$nuke"
                deletedsomething=1
            fi
        done
    fi
else
    db2 No stale directories to delete.
fi

if [[ -s master-deletefiles ]]; then
    linecount=$(wc -l < master-deletefiles)

    if [[ -n $skipdelete ]]; then
        echo Not deleting $linecount stale files.  Delete list is:
        cat master-deletefiles
        echo
    else
        db2 Removing $linecount stale files.
        xopts=()
        (( VERBOSE >= 4 )) && xopts=(-t)
        tr '\n' '\0' < master-deletefiles | (pushd $DESTD; xargs $xopts -0 rm -f ; popd)
        deletedsomething=1
    fi
else
    db2 No stale files to delete.
fi

if [[ -n $deletedsomething && -n $KEEPDIRTIMES ]]; then

    echo KEEPDIRTIMES not yet supported.
    # XXX call rsync again with just the dirs which we might have changed by
    # deleting, and all of their parents.
    # Or call it with all dirs in the modules given a command line option.
    # Implement dirname in awk.
fi

# State saving
# ============
if [[ -z $skiptimestamp ]]; then
    db2 Saving mirror time to $TIMEFILE
    if [[ -e $TIMEFILE ]]; then
        mv $TIMEFILE $TIMEFILE.prev
    fi
    echo LASTTIME=$starttime > $TIMEFILE

    if (( ? != 0 )); then
        (>&2 echo Problem saving timestamp file $TIMEFILE)
        exit 1
    fi
else
    db2 Skipping timestamp save.
    finish
fi

# Mirrormanager Checkin
# =====================
# At this point we know that we had a clean run with no complaints from rsync.
# So for each module we mirrored, the file list is correct.
# This means (assuming that no excludes are being passed) that the
# alldirs-$module file is accurate and we can simply report its contents to
# mirrormanager.
if [[ -z $CHECKIN_SITE ]]; then
    finish
fi

db2 Performing mirrormanager checkin
mm=mirrormanager-payload

# The json produced by report_mirror will start with a bracket, followed by
# info for each module, followed by some data relating to the host and site
# being reported.
echo '{' > $mm

for module in $MODULES; do
    moduledir=$MODULEMAPPING[$module]

    # The beginning of the json bit
    cat >>$mm <<EOF
    "$module": {
        "dirtree": {
EOF

    # Output the data for each directory.  MM doesn't want the
    # directory name.
    for l in $(cat alldirs-$module); do
        cat >>$mm <<EOF
            "${l/$moduledir\/}": {},
EOF
    done

    # The data sent by report_mirror always includes a blank directory; add it
    # manually here which conveniently means we don't have to deal with the
    # trailing comma.
    cat >>$mm <<EOF
            "": {}
        },
        "enabled": "1"
    },
EOF
done

cat >>$mm <<EOF
    "global": {
        "enabled": "1",
        "server": "$MIRRORMANAGER"
    },
    "host": {
        "enabled": "1",
        "name": "$CHECKIN_HOST"
    },
    "site": {
        "enabled": "1",
        "name": "$CHECKIN_SITE",
        "password": "$CHECKIN_PASSWORD"
    },
    "stats": {},
    "version": 0
}
EOF

# XXX gzip the payload and change the content type to application/gzip

# Now actually upload the payload
#$CURL -H "Content-Type: application/json" --data @$mm $MIRRORMANAGER

finish
