#!/bin/zsh
LANG=C
# Simple script to grab the file list from Fedora and rsync everything that's
# changed since the last time we pulled.
#
# Originally written by Jason Tibbitts <tibbs@math.uh.edu> in 2016.
# Donated to the public domain.  If you require a statement of license, please
# consider this work to be licensed as "CC0 Universal", any version you choose.

# Variables in upper case are user configurables.

# Do this absolutely first
starttime=$(date +%s)
# Paranoia
starttime=$(($starttime-5))

# Utility functions

db () { (( VERBOSE >= 2 )) && echo '>>' $* }
db2 () { (( VERBOSE >= 3 )) && echo '>>>>' $* }
b3 () { (( VERBOSE >= 4 )) && echo '>>>>>>' $* }
sep () { (( VERBOSE >= 1 )) && echo '============================================================' }

finish () {
    if (( $VERBOSE >= 1 )); then
        echo -n 'Mirror finished: '
        date
        exit 0
    fi
}

# Parse args
while [[ $# > 1 ]]; do
    opt=$1
    case $opt in
        -c)
            cfgfile=$2
            shift
            if [[ ! -r $cfgfile ]]; then
                (>&2 echo Cannot read $cfgfile)
                exit 1
            fi
            ;;
        -d)
            verboseopt=$2
            shift
            ;;
        -t)
            backdate=$2
            shift
            ;;
        -T)
            backdate=$(date -d "$2" +%s)
            shift
            ;;
        *)
            (>&2 echo "Unrecognized argument.")
            exit 1
            ;;
    esac
    shift
done

# Mapping from module names to directories under fedora-buffet
# ZSHISM (initialize associative array)
typeset -A MODULEMAPPING
MODULEMAPPING=(
    fedora-alt          alt
    fedora-archive      archive
    fedora-enchilada    fedora
    fedora-epel         epel
    fedora-secondary    fedora-secondary
    )

# Default arguments; override in quick-fedora-mirror.conf
VERBOSE=0

DESTD=
TIMEFILE=

REMOTE=rsync://dl.fedoraproject.org
FILELIST=fullfiletimelist

RSYNC=/usr/bin/rsync
#ZSHISM? (initialize array with unsplit args)
RSYNCOPTS=(-aSH -f 'R .~tmp~' --delete-delay --delay-updates)

MASTERMODULE=fedora-buffet
MIRRORBUFFET=0
MODULES=(fedora-enchilada fedora-epel)

# Load up the configuration file
for file in $cfgfile /etc/quick-fedora-mirror.conf \
        ~/.config/quick-fedora-mirror.conf \
        $(dirname $0)/quick-fedora-mirror.conf \
        ./quick-fedora-mirror.conf; do
    if [[ -r $file ]]; then
        source $file
        break
    fi
done

# Override with the command-line option
[[ -n $verboseopt ]] && VERBOSE=$verboseopt

# Check that the required parameters were provided
if [[ -z $DESTD ]]; then
    (>&2 echo "You must define DESTD in your configuration file ($configfile).")
fi
if [[ -z $TIMEFILE ]]; then
    (>&2 echo "You must define TIMEFILE in your configuration file ($configfile).")
fi

# Find the previous mirror time, and backdate if necessary
LASTTIME=0
if [[ -r $TIMEFILE ]]; then
    source $TIMEFILE
fi
if [[ -n $backdate ]]; then
    LASTTIME=$backdate
fi

tempd=$(mktemp -d -t quick-mirror.XXXXXXXXXX)
trap "rm -rf $tempd" EXIT
cd $tempd

# Modify RSYNCOPTS based on verbosity
# ZSHISM? (;& explicit case fallthrough)
case $VERBOSE in
    8)
        echo Loads of debugging.
        set -x
        ;&
    7)
        RSYNCOPTS+=(--progress)
        ;&
    6)
        echo Times:
        echo LASTTIME=$LASTTIME
        echo starttime=$starttime
        echo TIMEFILE=$TIMEFILE
        echo Dirs:
        echo tempd=$tempd
        echo DESTD=$DESTD
        echo Rsync:
        echo REMOTE=$REMOTE
        echo MASTERMODULE=$REMOTE
        echo RSYNC=$RSYNC
        echo RSYNCOPTS=$RSYNCOPTS
        echo Modules:
        echo MODULES=$MODULES
        echo MODULEMAPPING=$MODULEMAPPING
        echo
        ;&
    5)  RSYNCOPTS+=(-v)
        ;&
    4)  RSYNCOPTS+=(-v)
        ;&
    3)
        ;&
    2)  echo -n 'Mirror starting: '; date; echo
        ;;
    1)  echo -n 'Mirror starting: '; date; echo
        ;&
    0)  RSYNCOPTS+=(-q)
        ;;
esac

if [[ $MIRRORBUFFET -ne '0' ]]; then
    # We want to mirror everything, so save the admin from listing the
    # individual odules.
    # ZSHISM (get keys from an associative array with (k))
    MODULES=(${(k)MODULEMAPPING})
fi

# We have to accumulate a big list of everything that needs to be
# transferred from all of the modules
for module in $MODULES; do
    sep
    db Processing $module

    # ZSHISM? (associative array indexing)
    moduledir=$MODULEMAPPING[$module]
    totallines=0

    # First fetch each filefiletimelist, and make one big transfer list from
    # all of them  Copy in the old file from our repo to speed up rsync in case
    # most of it didn't change
    rm -f $FILELIST
    if [[ -f $DESTD/$moduledir/$FILELIST ]]; then
        cp -p $DESTD/$moduledir/$FILELIST .
        filelisttime=$(stat --format=%Y $FILELIST)
    fi


    db2 $RSYNC $RSYNCOPTS $REMOTE/$module/$FILELIST .
    sleep=1
    while true; do
        $RSYNC $RSYNCOPTS $REMOTE/$module/$FILELIST .
        rsyncreturn=$?
        # rsync will return 5 if the host says it's too busy, and 10 if the
        # connection was refused or the host doesn't resolve.
        (( rsyncreturn != 5 && rsyncreturn != 10 )) && break
        db rsync failed: sleeping for $sleep
        sleep $sleep
        sleep=$(( sleep*2 ))
        if (( sleep > 1000 )); then
            (>&2 echo "Could not sync $REMOTE/$module/$FILELIST")
            exit 1
        fi
    done

    if [[ $filelisttime == $(stat --format=%Y $FILELIST) ]]; then
        db No change in file list mtime.  Skipping $module.
        continue
    fi

    db ++ Extracting lists

    # Get files on the server which changed since the last mirror
    awk "{if (\$1 >= $LASTTIME) {print \"$moduledir/\" substr(\$0, 14)}}" < $FILELIST > newfiles-$module
    # We always want to transfer the file list itself in the transaction.
    echo $moduledir/$FILELIST >> newfiles-$module
    linecount=$(wc -l < newfiles-$module)
    db2 Found $linecount new or updated files in $module since last run.
    cat newfiles-$module >> transferlist
    totallines=$((totallines+linecount))

    # Dirs on the werver which changed since the last mirror
    awk "{if (\$1 >= $LASTTIME && \$2 == \"d\") {print \"$moduledir/\" substr(\$0, 14)}}" < $FILELIST > newdirs-$module
    linecount=$(wc -l < newdirs-$module)
    db2 Found $linecount new or updated dirs in $module since last run.
    cat newdirs-$module >> transferlist
    totallines=$((totallines+linecount))

    awk "{if (\$2 == \"f\" || \$2 == \"l\") {print \"$moduledir/\" substr(\$0, 14)}}" < $FILELIST > allfiles-$module
    linecount=$(wc -l < allfiles-$module)
    db2 Found $linecount remote files in $module.

    # Get a list of all of the directories which should be in the repository
    awk "{if (\$2 == \"d\") {print \"$moduledir/\" substr(\$0, 14)}}" < $FILELIST > alldirs-$module
    linecount=$(wc -l < alldirs-$module)
    db2 Found $linecount remote dirs in $module.

    # We want to delete any files, symlinks or directories  which exist locally
    # but which don't exist on the server.  If we do this here, before the
    # transfer, the directory mtimes will be correct after the transfer.
    if [[ -d $DESTD/$moduledir ]]; then
        db ++ Generating local dir lists
        pushd $DESTD
        find $moduledir/* -type d > $tempd/localdirs-$module
        popd

        linecount=$(wc -l < localdirs-$module)
        db2 Found $linecount local dirs in $module.

        # Computes the set difference between the first file and the third.
        sort alldirs-$module alldirs-$module localdirs-$module | uniq -u > deletedirs-$module
        linecount=$(wc -l < deletedirs-$module)
        # XXX push these deletes down until after the big rsync run
        db ++ Recursively removing $linecount stale dirs from $moduledir.
        for nuke in $(cat deletedirs-$module); do
            if [[ -d "$DESTD/$nuke" ]]; then
                db3 Removing $nuke
                rm -rf "$DESTD/$nuke"
            fi
        done

        # Find dirs on the server which are missing on the client
        sort localdirs-$module localdirs-$module alldirs-$module | uniq -u > missingdirs-$module
        linecount=$(wc -l < missingdirs-$module)
        db2 Found $linecount missing dirs in $module.
        cat missingdirs-$module >> transferlist
        totallines=$((totallines+linecount))

        db ++ Generating local file lists
        pushd $DESTD
        echo find $moduledir/* -type f -o -type l > $tempd/localfiles-$module
        find $moduledir/* -type f -o -type l > $tempd/localfiles-$module
        popd

        linecount=$(wc -l < localfiles-$module)
        db2 Found $linecount local files in $module.


        sort allfiles-$module allfiles-$module localfiles-$module | uniq -u > deletefiles-$module
        linecount=$(wc -l < deletefiles-$module)
        # XXX push these deletes down until after the big rsync run
        db ++ Removing $linecount stale files from $module.
        for nuke in $(cat deletefiles-$module); do
            if [[ -f "$nuke" || -h "$nuke" ]]; then
                db3 Removing $nuke
                rm -f "$DESTD/$nuke"
            fi
        done

        # Find files on the server which are missing on the client
        sort localfiles-$module localfiles-$module allfiles-$module | uniq -u > missingfiles-$module
        linecount=$(wc -l < missingfiles-$module)
        db2 Found $linecount missing files in $module.
        cat missingfiles-$module >> transferlist
        totallines=$((totallines+linecount))

    fi
    db Finished processing.  Added $totallines files and dirs to the transfer list.
done

if [[ ! -e transferlist ]]; then
    db No changed files.
    finish
fi

# rsync prefers sorted file lists and will complain if there are duplicates
sort -u transferlist > transferlist.sorted
linecount=$(wc -l < transferlist.sorted)
db Beginning transfer of $linecount files.

# Now we have a list of everything which has changed recently in every module
# we want, pass that to rsync (non recursive mode!) and it should transfer just
# the changed files without having to pull the entire huge file list.
db2 $RSYNC $RSYNCOPTS files-from transferlist.sorted $REMOTE $DESTD
sleep=1
while true; do
    $RSYNC $RSYNCOPTS --files-from transferlist.sorted $REMOTE/$MASTERMODULE/ $DESTD
    rsyncreturn=$?
    (( rsyncreturn != 5 && rsyncreturn != 10 )) && break
    db rsync failed: sleeping for $sleep
    sleep $sleep
    sleep=$(( sleep*2 ))
    if (( sleep > 1000 )); then
        (>&2 echo "Could not sync files from $REMOTE/$module")
        exit 1
    fi
done

mv $TIMEFILE $TIMEFILE.prev

db Saving mirror time to $TIMEFILE
echo LASTTIME=$starttime > $TIMEFILE

if (( ? != 0 )); then
    (>&2 echo Problem saving timestamp file $TIMEFILE)
    exit 1
fi

finish
