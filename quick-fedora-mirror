#!/bin/zsh
# Simple script to grab the file list from Fedora and rsync everything that's
# changed since the last time we pulled.
#
# Originally written by Jason Tibbitts <tibbs@math.uh.edu> in 2016.
# Donated to the public domain.  If you require a statement of license, please
# consider this work to be licensed as "CC0 Universal", any version you choose.

# Do this absolutely first
STARTTIME=$(date +%s)
# Paranoia
STARTTIME=$(($STARTTIME-5))

# Utility functions

db () {
    (( VERBOSE >= 2 )) && echo \>\> $*
}

# Mapping from module names to directories under fedora-buffet
# ZSHISM (initialize associative array)
typeset -A MODULEMAPPING
MODULEMAPPING=(
    fedora-buffet0  ''
    fedora-buffet   ''
    fedora-alt      alt
    fedora-archive  archive
    fedora-enchilada fedora
    fedora-epel     epel
    )

# Default arguments; override in quick-fedora-mirror.conf
VERBOSE=0

DESTD=/srv/mirror/pub
TIMEFILE=$DESTD/last-fedora-mirror

REMOTE=rsync://dl.fedoraproject.org
FILELIST=fullfiletimelist

RSYNC=/usr/bin/rsync
#ZSHISM? (initialize array with unsplit args)
RSYNCOPTS=(-aSH -f 'R .~tmp~' --delete-delay --delay-updates)

MASTERMODULE=fedora-buffet
MIRRORBUFFET=0
MODULES=(fedora-epel)

# Load up the configuration file
for i in /etc/quick-fedora-mirror.conf \
        ~/.config/quick-fedora-mirror.conf \
        $(dirname $0)/quick-fedora-mirror.conf \
        ./quick-fedora-mirror.conf; do
    if [[ -f $i ]]; then
        source $i
    fi
done

LASTTIME=0
if [[ -r $TIMEFILE ]]; then
    source $TIMEFILE
fi

TEMPD=$(mktemp -d -t quick-mirror.XXXXXXXXXX)
cd $TEMPD
trap "rm -rf $TEMPD" EXIT


# Modify RSYNCOPTS based on verbosity
# ZSHISM? (;& explicit case fallthrough)
case $VERBOSE in
    8)
        set +x
        ;&
    7)
        RSYNCOPTS+=(--progress)
        ;&
    6)
        echo Times:
        echo LASTTIME=$LASTTIME
        echo STARTTIME=$STARTTIME
        echo TIMEFILE=$TIMEFILE
        echo Dirs:
        echo TEMPD=$TEMPD
        echo DESTD=$DESTD
        echo Rsync:
        echo REMOTE=$REMOTE
        echo MASTERMODULE=$REMOTE
        echo RSYNC=$RSYNC
        echo RSYNCOPTS=$RSYNCOPTS
        echo Modules:
        echo MODULES=$MODULES
        echo MODULEMAPPING=$MODULEMAPPING
        ;&
    5)  RSYNCOPTS+=(-v)
        ;&
    4)  RSYNCOPTS+=(-v)
        ;&
    3)
        ;&
    2)  echo -n 'Mirror starting: '; date
        ;;
    1)  echo -n 'Mirror starting: '; date
        ;&
    0)  RSYNCOPTS+=(-q)
        ;;
esac

if [[ $MIRRORBUFFET -ne '0' ]]; then
    # We want to mirror everything, so save the admin from listing the
    # individual odules.
    # ZSHISM (get keys from an associative array with (k))
    MODULES=${(k)MODULEMAPPING}
fi

# We have to accumulate a big list of everything that needs to be
# transferred from all of the modules
for module in $MODULES; do
    db Processing $module
    moduledir=$MODULEMAPPING[$module]

    # First fetch each filefiletimelist, and make one big transfer list from
    # all of them
    rm -f fullfiletimelist

    db -- $RSYNC $RSYNCOPTS $REMOTE/$module/$FILELIST .
    sleep=1
    while true; do
        $RSYNC $RSYNCOPTS $REMOTE/$module/$FILELIST .
        (( ? == 0 )) && break
        db rsync failed: sleeping for $sleep
        sleep $sleep
        sleep=$(( sleep*2 ))
        if (( sleep > 1000 )); then
            echo "Could not sync $REMOTE/$module/$FILELIST"
            exit 1
        fi
    done


    # Handle error returns.  5 is "too many connections"
    # We probably want to sleep with backoff and retry, and pull the rsync call
    # out to a separate function to make that easier.

    # ZSHISM? (associative array indexing)
    db ++ Extracting lists
    awk "{if (\$1 >= $LASTTIME) {print \"$moduledir/\"\$3}}" < $FILELIST >> newfiles
    # We always want to transfer the file list itself in the transaction.
    echo $moduledir/$FILELIST >> newfiles

    # Find updated dirs
    awk "{if (\$1 >= $LASTTIME && \$2 == \"d\") {print \"$moduledir/\"\$3}}" < $FILELIST >> newdirs

    # Get just a list of all of all files and symlinks which should now be in the repository
    awk "{if (\$2 == \"f\" || \$2 == \"l\") {print \"$moduledir/\"\$3}}" < $FILELIST >> allfiles

    # And a list of all of the directories which should be in the repository
    awk "{if (\$2 == \"d\") {print \"$moduledir/\"\$3}}" < $FILELIST >> alldirs

    # We want to delete any files, symlinks or directories  which exist locally
    # but which don't exist on the server.  If we do this here, before the
    # transfer, the directory mtimes will be correct after the transfer.
    if [[ -d $DESTD/$moduledir ]]; then
        db ++ Generating local dir lists
        pushd $DESTD
        find $moduledir/* -type d -print > $TEMPD/localdirs
        popd

        # Computes the set difference between the first file and the third.
        sort alldirs alldirs localdirs | uniq -u > dirs-to-delete
        db ++ Removing stale dirs
        for nuke in $(cat dirs-to-delete); do
            if [[ -d $DESTD/$nuke ]]; then
                rm -rf $DESTD/$nuke
            fi
        done

        db ++ Generating local file lists
        pushd $DESTD
        find $moduledir/* -type f -o -type l -print > $TEMPD/localfiles
        popd
        sort allfiles allfiles localfiles | uniq -u > files-to-delete
        db ++ Removing stale files
        for nuke in $(cat files-to-delete); do
            if [[ -f $nuke || -h $nuke ]]; then
                rm -f $DESTD/$nuke
            fi
        done
    fi
    db Finished processing
done

# rsync docs suggest sorting the list for efficiency
db Beginning transfer
sort newfiles > newfiles.sorted

# Now we have a list of everything which has changed recently in every module
# we want, pass that to rsync (non recursive mode!) and it should transfer just
# the changed files without having to pull the entire huge file list.
db $RSYNC $RSYNCOPTS --files-from newfiles.sorted $REMOTE $DESTD
sleep=1
while true; do
    $RSYNC $RSYNCOPTS --files-from newfiles.sorted $REMOTE/$MASTERMODULE/ $DESTD
    (( ? == 0 )) && break
    db rsync failed; sleeping for $sleep
    sleep $sleep
    sleep=$(( sleep*2 ))
    if (( sleep > 1000 )); then
        echo "Could not sync files from $REMOTE/$module"
        exit 1
    fi
done

db Saving mirror time to $TIMEFILE
echo LASTTIME=$STARTTIME > $TIMEFILE

if (( $VERBOSE >= 1 )); then
    echo -n 'Mirror finished: '
    date
fi
